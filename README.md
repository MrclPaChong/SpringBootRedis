Redis是一个非常快速的、开源的、使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、非关系类型的、Key-Value数据库，并提供多种语言的API
Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
Redis支持数据的备份，即master-slave模式的数据备份。


String: ke value 可以存储任何数据
      存储对象信息
      
List: 有序 值可重复
      商品列表存储
      多线程 用户邮件群发
      
Set：无序 唯一 (值不可重复)
      用户注册重复提交
      APP提交--随机返回同一时间内不重复的问题
      获取随机，乱序的试题
      
Zset: Set+List 结合   有序、 元素唯一
      话费充值
      话费排行榜
      扩展：游戏充值排行榜、积分排行榜、微博热搜...
 
Hash：一对多 map里面套map
     // key{
          --数据
            Field{
                    A:lisi
                    B:wangwu 
                    C:posk
            }
          --数据
      //}
     id	type	        name	code	   value order_by	is_active	    create_time
     1	ReviewStatus	审核状态	Passed	    通过	1	            1	    2019/10/25 22:03:02
     2	ReviewStatus	审核状态	NotPassed	不通过	2	            1	    2019/10/25 22:03:02
     3	Sex	            性别	Female	    女性	1	            1	    2019/10/25 22:03:02
     4	Sex	            性别	Male	    男性	2	            1	    2019/10/25 22:03:02
     5	Color	        颜色	Red	        红色	1	            1	    2019/10/25 22:54:02
     6	Color	        颜色	Black	    黑色	2	            1	    2019/10/25 22:54:38
     7	Color	        颜色	White	    白色	3	            1	    2019/10/25 22:54:58
     8	Color	        颜色	Pink	    粉色	4	            1	    2019/10/25 22:55:09
     9	Color	        颜色	brond	    棕色	5	            1	    2019/10/31 21:34:13
     10	HouseType	    户型	ThreeTwo	三房两厅	1	            1	    2019/10/31 21:42:28
     11	HouseType	    户型	TwoOne	    两房一厅	2	            1	    2019/10/31 21:43:05

      
布隆过滤器  位数组的形势+多层hash函数

Redis的Hash   Map = key -- value
                                -- value对
              key -- map (field -- value对)
                                -- value对
                                
前端：下拉框：颜色Color：
                红色：red 
                黑色：black
              
              
实例解读什么是Redis缓存穿透、缓存雪崩和缓存击穿
    https://baijiahao.baidu.com/s?id=1619572269435584821&wfr=spider&for=pc                
缓存穿透：
        问题：[key压根不存在]请求查询数据库压根不存在的数据，也就是缓存和数据库都查询不到的这条数据，但是请求每次都会打到DB数据上面去
        后果：大量的、无意义的查询落到DB上，明显会增加数据库的查询能力，严重者可能发生宕机。
        解决方案：
                穿透方案一：给Redis 设置一个key的 元素为""的值
                穿透方案二：限流(令牌桶) （组件-hystrix、guava提供的RateLimiter）
                           https://www.cnblogs.com/cjsblog/p/9379516.html
                其他解决方案：Set集合、布隆过滤器 (上线前需要从数据库获取塞进去)
                
缓存击穿：
        问题：[key存在,但某一时刻失效]在平常高并发的系统中，大量请求去查询一个存在的key时，此时这个key突然失效，就会导致大量的请求打到DB数据库上去
        后果：某一时刻DB数据库请求查询量过大，压力剧增。
        解决方案：本质上看，其实这是高并发请求对应的多线程同时去查询数据库的这条数据，所以我们在第一个查询拿不到数据的请求上使用
                一个[互斥锁]来锁住它，其他线程走到这步拿不到锁就等待，知道第一个请求拿到数据，塞进缓存。后面的线程直接走缓存
                
                --
                互斥锁具有以下特点：
                ·原子性：把一个互斥锁定义为一个原子操作，这意味着操作系统保证了如果一个线程锁定了互斥锁，则没有其他线程可以在同一时间成功锁定这个互斥量。               
                ·唯一性：如果一个线程锁定一个互斥量，在它接触锁定之前，没有其他线程可以锁定这个互斥量。           
                ·非繁忙等待：如果一个线程已经锁定了一个互斥锁，第二个线程又试图去锁定这个互斥锁，则第二个线程将被挂起（不占用CPU资源），直到第一个线程解锁，第二个线程则被唤醒并继续执行，同时锁定这个互斥量
                --
                
                击穿方案一：分布式锁实现 -互斥锁
                击穿方案二：限流(令牌桶) （组件-hystrix、guava提供的RateLimiter）
                https://www.cnblogs.com/cjsblog/p/9379516.html
                
缓存雪崩：
        问题：当某一时刻发生大规模的缓存失效的情况，比如缓存服务宕机了，会有大量的请求直接进来打到DB上，
        结果DB扛不住，直接宕机。
        解决方案：
                 雪崩方案一：请求限流(限流组件)
                 雪崩方案二：Redis主从集群部署
                 雪崩方案三：设定持久化策略迅速恢复
        (
        https://baijiahao.baidu.com/s?id=1654694618189745916&wfr=spider&for=pc
        RDB：快照
        {
            RDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。
            
            RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。
            
            在我们安装了redis之后，所有的配置都是在redis.conf文件中，里面保存了RDB和AOF两种持久化机制的各种配置。
            
            既然RDB机制是通过把某个时刻的所有数据生成一个快照来保存，那么就应该有一种触发机制，是实现这个过程。对于RDB来说，提供了三种机制：save、bgsave、自动化。
        }
        AOF: 日志追击
        {
            全量备份总是耗时的，有时候我们提供一种更加高效的方式AOF，工作机制很简单，redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录。
        }
        )
                
热点数据失效：
            问题：对于一些热点数据而言，在某一时刻集体失效，导致大量的请求落在DB上。
            解决方案：
                    方案一：让这些热点永不失效、
                    方案二：错开这些热点数据的失效时间(随机数API生成)
                    
                    
抢红包系统：
           发红包：二倍均值法
           问题：解决统一用户可以反复抢红包
           方案：一：Redis的分布式锁  本demo采用方案
                 二：Redisson
                 三:zookeeper
缓存：
    @Cacheable: 获取并将给定的内容添加进缓存(缓存不存在时才添加进去)
    @CacheEvict：失效缓存
    @CachePut: 将给定的内容添加进缓存(不管缓存 存在不存在 都添加进去)